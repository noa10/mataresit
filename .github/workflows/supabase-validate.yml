name: Supabase Code Validation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'supabase/**'
      - '.github/workflows/supabase-validate.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'supabase/**'
      - '.github/workflows/supabase-validate.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to validate against'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_migration_validation:
        description: 'Skip migration file validation'
        required: false
        default: false
        type: boolean

env:
  SUPABASE_CLI_VERSION: '1.127.4'



jobs:
  # Validate Supabase Configuration
  validate:
    name: Validate Supabase Configuration
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: config
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Deploying to: $ENVIRONMENT"

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate Supabase configuration
        run: |
          # Check if supabase directory exists
          if [ ! -d "supabase" ]; then
            echo "Error: supabase directory not found"
            exit 1
          fi

          # Validate config.toml
          if [ ! -f "supabase/config.toml" ]; then
            echo "Error: supabase/config.toml not found"
            exit 1
          fi

          echo "✅ Supabase configuration is valid"

      - name: Lint Edge Functions
        run: |
          if [ -d "supabase/functions" ]; then
            echo "Linting Edge Functions..."
            for func_dir in supabase/functions/*/; do
              if [ -d "$func_dir" ]; then
                func_name=$(basename "$func_dir")
                echo "Checking function: $func_name"

                # Check for index.ts
                if [ ! -f "$func_dir/index.ts" ]; then
                  echo "Warning: $func_name missing index.ts"
                fi
              fi
            done
          else
            echo "No Edge Functions found"
          fi

  # Database Migration Validation
  validate-migrations:
    name: Validate Database Migrations
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.skip_migration_validation != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate migration files
        run: |
          set -e  # Exit on any error

          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "🔍 Starting migration file validation for environment: $ENVIRONMENT"

          # Check if migrations directory exists
          if [ ! -d "supabase/migrations" ]; then
            echo "ℹ️ No migrations directory found - skipping migration validation"
            exit 0
          fi

          # Count migration files
          MIGRATION_COUNT=$(find supabase/migrations -name "*.sql" | wc -l)
          echo "📋 Found $MIGRATION_COUNT migration files"

          if [ "$MIGRATION_COUNT" -eq 0 ]; then
            echo "ℹ️ No migration files found - validation complete"
            exit 0
          fi

          # Validate migration file naming convention
          echo "🔍 Validating migration file naming convention..."
          INVALID_NAMES=0

          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "  Checking: $filename"

              # Check naming pattern: YYYYMMDDHHMMSS_description.sql
              if [[ ! "$filename" =~ ^[0-9]{14}_[a-zA-Z0-9_-]+\.sql$ ]]; then
                echo "  ❌ Invalid naming convention: $filename"
                echo "     Expected format: YYYYMMDDHHMMSS_description.sql"
                INVALID_NAMES=$((INVALID_NAMES + 1))
              else
                echo "  ✅ Valid naming: $filename"
              fi
            fi
          done

          if [ "$INVALID_NAMES" -gt 0 ]; then
            echo "❌ Found $INVALID_NAMES migration files with invalid naming"
            exit 1
          fi

          echo "✅ All migration files follow correct naming convention"

          # Validate SQL syntax in migration files
          echo "🔍 Validating SQL syntax in migration files..."
          SYNTAX_ERRORS=0

          # Install PostgreSQL client for SQL validation
          sudo apt-get update -qq
          sudo apt-get install -y postgresql-client

          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "  Validating SQL syntax: $filename"

              # Check for basic SQL syntax issues
              if ! psql --set=ON_ERROR_STOP=1 --quiet --no-psqlrc -f "$file" --dry-run 2>/dev/null; then
                # Try alternative validation - check for common SQL patterns
                if grep -q -E "(CREATE|ALTER|DROP|INSERT|UPDATE|DELETE|SELECT)" "$file"; then
                  # Check for obvious syntax errors
                  if grep -q -E "(;[[:space:]]*$|;[[:space:]]*--)" "$file"; then
                    echo "  ✅ Basic SQL structure valid: $filename"
                  else
                    echo "  ⚠️ Warning: No semicolon termination found in: $filename"
                  fi
                else
                  echo "  ❌ No SQL statements found in: $filename"
                  SYNTAX_ERRORS=$((SYNTAX_ERRORS + 1))
                fi
              else
                echo "  ✅ SQL syntax valid: $filename"
              fi

              # Check file size (warn if empty or too large)
              file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
              if [ "$file_size" -eq 0 ]; then
                echo "  ⚠️ Warning: Empty migration file: $filename"
              elif [ "$file_size" -gt 1048576 ]; then  # 1MB
                echo "  ⚠️ Warning: Large migration file (${file_size} bytes): $filename"
              fi
            fi
          done

          if [ "$SYNTAX_ERRORS" -gt 0 ]; then
            echo "❌ Found $SYNTAX_ERRORS migration files with syntax issues"
            exit 1
          fi

          echo "✅ All migration files have valid SQL syntax"

          # Check for migration dependencies and ordering
          echo "🔍 Validating migration file ordering..."

          # List migration files in chronological order
          echo "📋 Migration files in chronological order:"
          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              timestamp=$(echo "$filename" | cut -d'_' -f1)
              echo "  $timestamp: $filename"
            fi
          done

          # Check for potential issues in migration content
          echo "🔍 Checking for common migration issues..."
          MIGRATION_WARNINGS=0

          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")

              # Check for potentially dangerous operations
              if grep -q -i "DROP TABLE\|DROP DATABASE\|TRUNCATE" "$file"; then
                echo "  ⚠️ Warning: Destructive operations found in $filename"
                MIGRATION_WARNINGS=$((MIGRATION_WARNINGS + 1))
              fi

              # Check for missing transaction blocks for complex operations
              if grep -q -i "ALTER TABLE\|CREATE INDEX" "$file" && ! grep -q -i "BEGIN\|START TRANSACTION" "$file"; then
                echo "  ℹ️ Info: Consider using transaction blocks in $filename"
              fi

              # Check for proper semicolon termination
              if ! grep -q ";" "$file"; then
                echo "  ⚠️ Warning: No SQL statements with semicolons found in $filename"
                MIGRATION_WARNINGS=$((MIGRATION_WARNINGS + 1))
              fi
            fi
          done

          if [ "$MIGRATION_WARNINGS" -gt 0 ]; then
            echo "⚠️ Found $MIGRATION_WARNINGS potential issues in migration files (review recommended)"
          fi

          echo "✅ Migration file validation completed successfully"
          echo "ℹ️ Note: Files validated for syntax and structure only - manual deployment required"

  # Edge Functions Validation
  validate-edge-functions:
    name: Validate Edge Functions
    runs-on: ubuntu-latest
    needs: [validate, validate-migrations]
    if: always() && needs.validate.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install TypeScript and dependencies
        run: |
          npm install -g typescript @types/node
          # Install Deno for Edge Functions validation
          curl -fsSL https://deno.land/x/install/install.sh | sh
          echo "$HOME/.deno/bin" >> $GITHUB_PATH

      - name: Validate Edge Functions
        run: |
          set -e  # Exit on any error

          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "🔍 Starting Edge Functions validation for environment: $ENVIRONMENT"

          # Check if functions directory exists
          if [ ! -d "supabase/functions" ]; then
            echo "ℹ️ No Edge Functions directory found - skipping validation"
            exit 0
          fi

          # Count function directories
          FUNCTION_COUNT=$(find supabase/functions -maxdepth 1 -type d ! -path supabase/functions | wc -l)
          echo "📋 Found $FUNCTION_COUNT Edge Function directories"

          if [ "$FUNCTION_COUNT" -eq 0 ]; then
            echo "ℹ️ No Edge Functions found - validation complete"
            exit 0
          fi

          # Validate each Edge Function
          echo "🔍 Validating Edge Functions structure and syntax..."
          VALIDATION_ERRORS=0

          for func_dir in supabase/functions/*/; do
            if [ -d "$func_dir" ]; then
              func_name=$(basename "$func_dir")
              echo "  Validating function: $func_name"

              # Check for required index.ts file
              if [ ! -f "$func_dir/index.ts" ]; then
                echo "  ❌ Missing index.ts in function: $func_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                continue
              fi

              echo "  ✅ Found index.ts for: $func_name"

              # Validate TypeScript syntax
              if ! deno check "$func_dir/index.ts" 2>/dev/null; then
                echo "  ❌ TypeScript syntax errors in: $func_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
              else
                echo "  ✅ TypeScript syntax valid for: $func_name"
              fi

              # Check for proper Deno imports and exports
              if grep -q "Deno.serve\|serve(" "$func_dir/index.ts"; then
                echo "  ✅ Found Deno.serve handler in: $func_name"
              else
                echo "  ⚠️ Warning: No Deno.serve handler found in: $func_name"
              fi

              # Check for proper TypeScript imports
              if grep -q "import.*from" "$func_dir/index.ts"; then
                echo "  ✅ Found import statements in: $func_name"
              fi

              # Check file size
              file_size=$(stat -f%z "$func_dir/index.ts" 2>/dev/null || stat -c%s "$func_dir/index.ts" 2>/dev/null || echo "0")
              if [ "$file_size" -eq 0 ]; then
                echo "  ❌ Empty function file: $func_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
              elif [ "$file_size" -gt 1048576 ]; then  # 1MB
                echo "  ⚠️ Warning: Large function file (${file_size} bytes): $func_name"
              fi

              # Check for common Edge Function patterns
              if grep -q "Request\|Response" "$func_dir/index.ts"; then
                echo "  ✅ Found Request/Response handling in: $func_name"
              else
                echo "  ⚠️ Warning: No Request/Response handling found in: $func_name"
              fi
            fi
          done

          if [ "$VALIDATION_ERRORS" -gt 0 ]; then
            echo "❌ Found $VALIDATION_ERRORS Edge Functions with validation errors"
            exit 1
          fi

          echo "✅ All Edge Functions validation completed successfully"
          echo "ℹ️ Note: Functions validated for structure and syntax only - manual deployment required"

          # List available functions for reference
          echo "📋 Available Edge Functions:"
          find supabase/functions -name "index.ts" -type f | sed 's|supabase/functions/||' | sed 's|/index.ts||' | sort || echo "No functions found"

  # Supabase Configuration Validation
  validate-deployment:
    name: Validate Supabase Configuration
    runs-on: ubuntu-latest
    needs: [validate, validate-migrations, validate-edge-functions]
    if: always() && needs.validate.result == 'success'
    environment: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Validate Supabase configuration
        run: |
          set -e  # Exit on any error

          echo "🔍 Validating Supabase configuration files..."

          # Check if config.toml exists
          if [ ! -f "supabase/config.toml" ]; then
            echo "❌ Error: supabase/config.toml not found"
            exit 1
          fi

          echo "✅ Found supabase/config.toml"

          # Validate config.toml syntax (basic TOML validation)
          if command -v python3 >/dev/null 2>&1; then
            python3 -c "
            import toml
            try:
                with open('supabase/config.toml', 'r') as f:
                    config = toml.load(f)
                print('✅ config.toml syntax is valid')

                # Check for required sections
                required_sections = ['api', 'db', 'studio', 'auth']
                for section in required_sections:
                    if section in config:
                        print(f'✅ Found required section: [{section}]')
                    else:
                        print(f'⚠️ Warning: Missing section: [{section}]')

            except Exception as e:
                print(f'❌ config.toml syntax error: {e}')
                exit(1)
" || echo "⚠️ Warning: Could not validate TOML syntax (python3/toml not available)"
          fi

          # Check for seed.sql if it exists
          if [ -f "supabase/seed.sql" ]; then
            echo "✅ Found supabase/seed.sql"

            # Basic SQL validation for seed file
            if grep -q -E "(INSERT|CREATE|ALTER)" "supabase/seed.sql"; then
              echo "✅ seed.sql contains SQL statements"
            else
              echo "⚠️ Warning: seed.sql appears to be empty or contains no SQL statements"
            fi
          else
            echo "ℹ️ No seed.sql file found (optional)"
          fi

          echo "✅ Supabase configuration validation completed"

      - name: Test Supabase connectivity
        run: |
          set -e  # Exit on any error

          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "🧪 Testing Supabase connectivity for environment: $ENVIRONMENT"

          if [[ "$ENVIRONMENT" == "production" ]]; then
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}"
          else
            SUPABASE_URL="${{ secrets.STAGING_SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.STAGING_SUPABASE_ANON_KEY }}"
          fi

          # Validate credentials with detailed debugging
          echo "🔍 Debugging validation credentials for $ENVIRONMENT environment:"
          echo "SUPABASE_URL: ${SUPABASE_URL:+SET (length: ${#SUPABASE_URL})}"
          echo "SUPABASE_ANON_KEY: ${SUPABASE_ANON_KEY:+SET (length: ${#SUPABASE_ANON_KEY})}"

          if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_ANON_KEY" ]; then
            echo "❌ Error: Missing Supabase credentials for $ENVIRONMENT"
            echo ""
            echo "🔧 TROUBLESHOOTING GUIDE:"
            echo "1. Verify these secrets are configured in GitHub repository settings:"
            if [ -z "$SUPABASE_URL" ]; then
              echo "   ❌ Missing: SUPABASE_URL (for production) or STAGING_SUPABASE_URL (for staging)"
            fi
            if [ -z "$SUPABASE_ANON_KEY" ]; then
              echo "   ❌ Missing: SUPABASE_ANON_KEY (for production) or STAGING_SUPABASE_ANON_KEY (for staging)"
            fi
            echo "2. Ensure secrets are configured for the 'Production' environment"
            echo "3. Check that secret values are not empty"
            exit 1
          fi

          echo "🔍 Testing Supabase URL: $SUPABASE_URL"

          # Test health endpoint with detailed error reporting
          echo "🏥 Testing health endpoint..."
          if curl -f -s --max-time 30 \
            -H "apikey: $SUPABASE_ANON_KEY" \
            "$SUPABASE_URL/health" > /dev/null; then
            echo "✅ Supabase health check passed"
          else
            echo "❌ Supabase health check failed"
            echo "🔍 Attempting to get more details..."
            curl -v -H "apikey: $SUPABASE_ANON_KEY" "$SUPABASE_URL/health" || true
            exit 1
          fi

          # Test database connectivity with detailed error reporting
          echo "🗄️ Testing database connectivity..."
          DB_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 \
            "$SUPABASE_URL/rest/v1/receipts?select=id&limit=1" \
            -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
            -H "apikey: $SUPABASE_ANON_KEY" || echo "000")

          echo "Database response code: $DB_RESPONSE"

          if [ "$DB_RESPONSE" = "200" ] || [ "$DB_RESPONSE" = "404" ]; then
            echo "✅ Database connectivity test passed (HTTP $DB_RESPONSE)"
          else
            echo "❌ Database connectivity test failed (HTTP $DB_RESPONSE)"
            echo "🔍 Attempting detailed request..."
            curl -v "$SUPABASE_URL/rest/v1/receipts?select=id&limit=1" \
              -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
              -H "apikey: $SUPABASE_ANON_KEY" || true
            exit 1
          fi

      - name: Test Edge Functions
        run: |
          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "🧪 Testing Edge Functions for environment: $ENVIRONMENT"

          if [[ "$ENVIRONMENT" == "production" ]]; then
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}"
          else
            SUPABASE_URL="${{ secrets.STAGING_SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.STAGING_SUPABASE_ANON_KEY }}"
          fi

          # Test key Edge Functions if they exist
          FUNCTIONS_TO_TEST=("stripe-webhook" "process-receipt" "manage-api-keys" "unified-search")
          FAILED_FUNCTIONS=()
          SUCCESSFUL_FUNCTIONS=()

          for func in "${FUNCTIONS_TO_TEST[@]}"; do
            echo "🔍 Testing function: $func"

            FUNC_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 \
              -X POST "$SUPABASE_URL/functions/v1/$func" \
              -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
              -H "Content-Type: application/json" \
              -d '{"test": true}' 2>/dev/null || echo "000")

            echo "Function $func response: HTTP $FUNC_RESPONSE"

            # Consider various response codes as success (function is deployed and responding)
            if [ "$FUNC_RESPONSE" = "200" ] || [ "$FUNC_RESPONSE" = "400" ] || [ "$FUNC_RESPONSE" = "401" ] || [ "$FUNC_RESPONSE" = "403" ]; then
              echo "✅ Function $func is responding (HTTP $FUNC_RESPONSE)"
              SUCCESSFUL_FUNCTIONS+=("$func")
            else
              echo "⚠️ Function $func may not be deployed or accessible (HTTP $FUNC_RESPONSE)"
              FAILED_FUNCTIONS+=("$func")
            fi
          done

          # Summary
          echo ""
          echo "📊 Edge Functions Test Summary:"
          echo "✅ Responding functions: ${#SUCCESSFUL_FUNCTIONS[@]}"
          echo "⚠️ Non-responding functions: ${#FAILED_FUNCTIONS[@]}"

          if [ ${#SUCCESSFUL_FUNCTIONS[@]} -gt 0 ]; then
            echo "✅ Successful: ${SUCCESSFUL_FUNCTIONS[*]}"
          fi

          if [ ${#FAILED_FUNCTIONS[@]} -gt 0 ]; then
            echo "⚠️ Failed: ${FAILED_FUNCTIONS[*]}"
            echo "ℹ️ Note: Some functions may not be deployed or may require specific authentication"
          fi

          # Don't fail the workflow if some functions are not responding
          # This allows for partial deployments and optional functions
          echo "✅ Edge Functions validation completed"

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate, validate-migrations, validate-edge-functions, validate-deployment]
    if: always()

    steps:
      - name: Log deployment success
        if: ${{ needs.validate-deployment.result == 'success' }}
        run: |
          echo "🚀 Supabase deployment successful!"
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Migrations: ${{ needs.validate-migrations.result }}"
          echo "Functions: ${{ needs.validate-edge-functions.result }}"
          echo "Validation: ${{ needs.validate-deployment.result }}"

      - name: Log deployment failure
        if: ${{ needs.validate.result == 'failure' || needs.validate-migrations.result == 'failure' || needs.validate-edge-functions.result == 'failure' }}
        run: |
          echo "❌ Supabase deployment failed!"
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Validation: ${{ needs.validate.result }}"
          echo "Migrations: ${{ needs.validate-migrations.result }}"
          echo "Functions: ${{ needs.validate-edge-functions.result }}"
          echo "Check workflow logs for details."

      - name: Log deployment status (fallback)
        if: always()
        run: |
          echo "=== Deployment Summary ==="
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Validation: ${{ needs.validate.result }}"
          echo "Migrations: ${{ needs.validate-migrations.result }}"
          echo "Functions: ${{ needs.validate-edge-functions.result }}"
          echo "Validation: ${{ needs.validate-deployment.result }}"

          echo "ℹ️ Slack notifications disabled"

          if [[ "${{ needs.validate-deployment.result }}" == "success" ]]; then
            echo "🚀 Deployment completed successfully!"
          else
            echo "❌ Deployment failed. Check logs above for details."
          fi
