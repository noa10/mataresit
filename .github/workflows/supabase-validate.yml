name: Supabase Code Validation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'supabase/**'
      - '.github/workflows/supabase-validate.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'supabase/**'
      - '.github/workflows/supabase-validate.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to validate against'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_migration_validation:
        description: 'Skip migration file validation'
        required: false
        default: false
        type: boolean

env:
  SUPABASE_CLI_VERSION: '1.127.4'



jobs:
  # Validate Supabase Configuration
  validate:
    name: Validate Supabase Configuration
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: config
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Deploying to: $ENVIRONMENT"

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate Supabase configuration
        run: |
          # Check if supabase directory exists
          if [ ! -d "supabase" ]; then
            echo "Error: supabase directory not found"
            exit 1
          fi

          # Validate config.toml
          if [ ! -f "supabase/config.toml" ]; then
            echo "Error: supabase/config.toml not found"
            exit 1
          fi

          echo "‚úÖ Supabase configuration is valid"

      - name: Lint Edge Functions
        run: |
          if [ -d "supabase/functions" ]; then
            echo "Linting Edge Functions..."
            for func_dir in supabase/functions/*/; do
              if [ -d "$func_dir" ]; then
                func_name=$(basename "$func_dir")
                echo "Checking function: $func_name"

                # Check for index.ts
                if [ ! -f "$func_dir/index.ts" ]; then
                  echo "Warning: $func_name missing index.ts"
                fi
              fi
            done
          else
            echo "No Edge Functions found"
          fi

  # Database Migration Validation
  validate-migrations:
    name: Validate Database Migrations
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.skip_migration_validation != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate migration files
        run: |
          set -e  # Exit on any error

          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "üîç Starting migration file validation for environment: $ENVIRONMENT"

          # Check if migrations directory exists
          if [ ! -d "supabase/migrations" ]; then
            echo "‚ÑπÔ∏è No migrations directory found - skipping migration validation"
            exit 0
          fi

          # Count migration files
          MIGRATION_COUNT=$(find supabase/migrations -name "*.sql" | wc -l)
          echo "üìã Found $MIGRATION_COUNT migration files"

          if [ "$MIGRATION_COUNT" -eq 0 ]; then
            echo "‚ÑπÔ∏è No migration files found - validation complete"
            exit 0
          fi

          # Validate migration file naming convention
          echo "üîç Validating migration file naming convention..."
          INVALID_NAMES=0

          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "  Checking: $filename"

              # Check naming pattern: YYYYMMDDHHMMSS_description.sql
              if [[ ! "$filename" =~ ^[0-9]{14}_[a-zA-Z0-9_-]+\.sql$ ]]; then
                echo "  ‚ùå Invalid naming convention: $filename"
                echo "     Expected format: YYYYMMDDHHMMSS_description.sql"
                INVALID_NAMES=$((INVALID_NAMES + 1))
              else
                echo "  ‚úÖ Valid naming: $filename"
              fi
            fi
          done

          if [ "$INVALID_NAMES" -gt 0 ]; then
            echo "‚ùå Found $INVALID_NAMES migration files with invalid naming"
            exit 1
          fi

          echo "‚úÖ All migration files follow correct naming convention"

          # Validate SQL syntax in migration files
          echo "üîç Validating SQL syntax in migration files..."
          SYNTAX_ERRORS=0

          # Install PostgreSQL client for SQL validation
          sudo apt-get update -qq
          sudo apt-get install -y postgresql-client

          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "  Validating SQL syntax: $filename"

              # Check for basic SQL syntax issues
              if ! psql --set=ON_ERROR_STOP=1 --quiet --no-psqlrc -f "$file" --dry-run 2>/dev/null; then
                # Try alternative validation - check for common SQL patterns
                if grep -q -E "(CREATE|ALTER|DROP|INSERT|UPDATE|DELETE|SELECT)" "$file"; then
                  # Check for obvious syntax errors
                  if grep -q -E "(;[[:space:]]*$|;[[:space:]]*--)" "$file"; then
                    echo "  ‚úÖ Basic SQL structure valid: $filename"
                  else
                    echo "  ‚ö†Ô∏è Warning: No semicolon termination found in: $filename"
                  fi
                else
                  echo "  ‚ùå No SQL statements found in: $filename"
                  SYNTAX_ERRORS=$((SYNTAX_ERRORS + 1))
                fi
              else
                echo "  ‚úÖ SQL syntax valid: $filename"
              fi

              # Check file size (warn if empty or too large)
              file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
              if [ "$file_size" -eq 0 ]; then
                echo "  ‚ö†Ô∏è Warning: Empty migration file: $filename"
              elif [ "$file_size" -gt 1048576 ]; then  # 1MB
                echo "  ‚ö†Ô∏è Warning: Large migration file (${file_size} bytes): $filename"
              fi
            fi
          done

          if [ "$SYNTAX_ERRORS" -gt 0 ]; then
            echo "‚ùå Found $SYNTAX_ERRORS migration files with syntax issues"
            exit 1
          fi

          echo "‚úÖ All migration files have valid SQL syntax"

          # Check for migration dependencies and ordering
          echo "üîç Validating migration file ordering..."

          # List migration files in chronological order
          echo "üìã Migration files in chronological order:"
          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              timestamp=$(echo "$filename" | cut -d'_' -f1)
              echo "  $timestamp: $filename"
            fi
          done

          # Check for potential issues in migration content
          echo "üîç Checking for common migration issues..."
          MIGRATION_WARNINGS=0

          for file in supabase/migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")

              # Check for potentially dangerous operations
              if grep -q -i "DROP TABLE\|DROP DATABASE\|TRUNCATE" "$file"; then
                echo "  ‚ö†Ô∏è Warning: Destructive operations found in $filename"
                MIGRATION_WARNINGS=$((MIGRATION_WARNINGS + 1))
              fi

              # Check for missing transaction blocks for complex operations
              if grep -q -i "ALTER TABLE\|CREATE INDEX" "$file" && ! grep -q -i "BEGIN\|START TRANSACTION" "$file"; then
                echo "  ‚ÑπÔ∏è Info: Consider using transaction blocks in $filename"
              fi

              # Check for proper semicolon termination
              if ! grep -q ";" "$file"; then
                echo "  ‚ö†Ô∏è Warning: No SQL statements with semicolons found in $filename"
                MIGRATION_WARNINGS=$((MIGRATION_WARNINGS + 1))
              fi
            fi
          done

          if [ "$MIGRATION_WARNINGS" -gt 0 ]; then
            echo "‚ö†Ô∏è Found $MIGRATION_WARNINGS potential issues in migration files (review recommended)"
          fi

          echo "‚úÖ Migration file validation completed successfully"
          echo "‚ÑπÔ∏è Note: Files validated for syntax and structure only - manual deployment required"

  # Edge Functions Validation
  validate-edge-functions:
    name: Validate Edge Functions
    runs-on: ubuntu-latest
    needs: [validate, validate-migrations]
    if: always() && needs.validate.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install TypeScript and dependencies
        run: |
          npm install -g typescript @types/node
          # Install Deno for Edge Functions validation
          curl -fsSL https://deno.land/x/install/install.sh | sh
          echo "$HOME/.deno/bin" >> $GITHUB_PATH

      - name: Validate Edge Functions
        run: |
          set -e  # Exit on any error

          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "üîç Starting Edge Functions validation for environment: $ENVIRONMENT"

          # Check if functions directory exists
          if [ ! -d "supabase/functions" ]; then
            echo "‚ÑπÔ∏è No Edge Functions directory found - skipping validation"
            exit 0
          fi

          # Count only actual function directories (exclude shared/test helper folders)
          FUNCTION_COUNT=$(find supabase/functions -mindepth 1 -maxdepth 1 -type d \
            ! -name "_*" \
            ! -name "__*" \
            | wc -l)
          echo "üìã Found $FUNCTION_COUNT Edge Function directories"

          if [ "$FUNCTION_COUNT" -eq 0 ]; then
            echo "‚ÑπÔ∏è No Edge Functions found - validation complete"
            exit 0
          fi

          # Validate each Edge Function
          echo "üîç Validating Edge Functions structure and syntax..."
          VALIDATION_ERRORS=0

          for func_dir in supabase/functions/*/; do
            if [ -d "$func_dir" ]; then
              func_name=$(basename "$func_dir")

              # Skip shared/test helper directories
              if [[ "$func_name" == _* ]] || [[ "$func_name" == __* ]]; then
                continue
              fi

              echo "  Validating function: $func_name"

              # Check for required index.ts file
              if [ ! -f "$func_dir/index.ts" ]; then
                echo "  ‚ÑπÔ∏è Skipping directory without index.ts: $func_name"
                continue
              fi

              echo "  ‚úÖ Found index.ts for: $func_name"

              # Validate TypeScript syntax only (parse check).
              # `deno fmt --check` exits non-zero for both syntax errors and formatting diffs,
              # so treat formatting-only failures as valid syntax.
              FMT_OUTPUT="$(deno fmt --check "$func_dir/index.ts" 2>&1 || true)"
              if [ -z "$FMT_OUTPUT" ] || echo "$FMT_OUTPUT" | grep -q "not formatted file"; then
                echo "  ‚úÖ TypeScript syntax valid for: $func_name"
              else
                echo "  ‚ùå TypeScript syntax errors in: $func_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
              fi

              # Check for proper Deno imports and exports
              if grep -q "Deno.serve\|serve(" "$func_dir/index.ts"; then
                echo "  ‚úÖ Found Deno.serve handler in: $func_name"
              else
                echo "  ‚ö†Ô∏è Warning: No Deno.serve handler found in: $func_name"
              fi

              # Check for proper TypeScript imports
              if grep -q "import.*from" "$func_dir/index.ts"; then
                echo "  ‚úÖ Found import statements in: $func_name"
              fi

              # Check file size
              file_size=$(stat -f%z "$func_dir/index.ts" 2>/dev/null || stat -c%s "$func_dir/index.ts" 2>/dev/null || echo "0")
              if [ "$file_size" -eq 0 ]; then
                echo "  ‚ùå Empty function file: $func_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
              elif [ "$file_size" -gt 1048576 ]; then  # 1MB
                echo "  ‚ö†Ô∏è Warning: Large function file (${file_size} bytes): $func_name"
              fi

              # Check for common Edge Function patterns
              if grep -q "Request\|Response" "$func_dir/index.ts"; then
                echo "  ‚úÖ Found Request/Response handling in: $func_name"
              else
                echo "  ‚ö†Ô∏è Warning: No Request/Response handling found in: $func_name"
              fi
            fi
          done

          if [ "$VALIDATION_ERRORS" -gt 0 ]; then
            echo "‚ùå Found $VALIDATION_ERRORS Edge Functions with validation errors"
            exit 1
          fi

          echo "‚úÖ All Edge Functions validation completed successfully"
          echo "‚ÑπÔ∏è Note: Functions validated for structure and syntax only - manual deployment required"

          # List available functions for reference
          echo "üìã Available Edge Functions:"
          find supabase/functions -name "index.ts" -type f | sed 's|supabase/functions/||' | sed 's|/index.ts||' | sort || echo "No functions found"

  # Supabase Configuration Validation
  validate-deployment:
    name: Validate Supabase Configuration
    runs-on: ubuntu-latest
    needs: [validate, validate-migrations, validate-edge-functions]
    if: always() && needs.validate.result == 'success'
    environment: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Validate Supabase configuration
        run: |
          set -e  # Exit on any error

          echo "üîç Validating Supabase configuration files..."

          # Check if config.toml exists
          if [ ! -f "supabase/config.toml" ]; then
            echo "‚ùå Error: supabase/config.toml not found"
            exit 1
          fi

          echo "‚úÖ Found supabase/config.toml"

          # Validate config.toml syntax (basic TOML validation)
          if command -v python3 >/dev/null 2>&1; then
            python3 <<'PYTHON_SCRIPT' || echo "‚ö†Ô∏è Warning: Could not validate TOML syntax (python3/toml not available)"
          import toml
          try:
              with open('supabase/config.toml', 'r') as f:
                  config = toml.load(f)
              print('‚úÖ config.toml syntax is valid')

              # Check for required sections
              required_sections = ['api', 'db', 'studio', 'auth']
              for section in required_sections:
                  if section in config:
                      print(f'‚úÖ Found required section: [{section}]')
                  else:
                      print(f'‚ö†Ô∏è Warning: Missing section: [{section}]')

          except Exception as e:
              print(f'‚ùå config.toml syntax error: {e}')
              exit(1)
          PYTHON_SCRIPT
          fi

          # Check for seed.sql if it exists
          if [ -f "supabase/seed.sql" ]; then
            echo "‚úÖ Found supabase/seed.sql"

            # Basic SQL validation for seed file
            if grep -q -E "(INSERT|CREATE|ALTER)" "supabase/seed.sql"; then
              echo "‚úÖ seed.sql contains SQL statements"
            else
              echo "‚ö†Ô∏è Warning: seed.sql appears to be empty or contains no SQL statements"
            fi
          else
            echo "‚ÑπÔ∏è No seed.sql file found (optional)"
          fi

          echo "‚úÖ Supabase configuration validation completed"

      - name: Test Supabase connectivity
        run: |
          set -e  # Exit on any error

          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "üß™ Testing Supabase connectivity for environment: $ENVIRONMENT"

          if [[ "$ENVIRONMENT" == "production" ]]; then
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}"
          else
            SUPABASE_URL="${{ secrets.STAGING_SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.STAGING_SUPABASE_ANON_KEY }}"
          fi

          # Validate credentials with detailed debugging
          echo "üîç Debugging validation credentials for $ENVIRONMENT environment:"
          echo "SUPABASE_URL: ${SUPABASE_URL:+SET (length: ${#SUPABASE_URL})}"
          echo "SUPABASE_ANON_KEY: ${SUPABASE_ANON_KEY:+SET (length: ${#SUPABASE_ANON_KEY})}"

          if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_ANON_KEY" ]; then
            echo "‚ùå Error: Missing Supabase credentials for $ENVIRONMENT"
            echo ""
            echo "üîß TROUBLESHOOTING GUIDE:"
            echo "1. Verify these secrets are configured in GitHub repository settings:"
            if [ -z "$SUPABASE_URL" ]; then
              echo "   ‚ùå Missing: SUPABASE_URL (for production) or STAGING_SUPABASE_URL (for staging)"
            fi
            if [ -z "$SUPABASE_ANON_KEY" ]; then
              echo "   ‚ùå Missing: SUPABASE_ANON_KEY (for production) or STAGING_SUPABASE_ANON_KEY (for staging)"
            fi
            echo "2. Ensure secrets are configured for the 'Production' environment"
            echo "3. Check that secret values are not empty"
            exit 1
          fi

          echo "üîç Testing Supabase URL: $SUPABASE_URL"

          # Test health endpoint with detailed error reporting
          echo "üè• Testing health endpoint..."
          if curl -f -s --max-time 30 \
            -H "apikey: $SUPABASE_ANON_KEY" \
            "$SUPABASE_URL/health" > /dev/null; then
            echo "‚úÖ Supabase health check passed"
          else
            echo "‚ùå Supabase health check failed"
            echo "üîç Attempting to get more details..."
            curl -v -H "apikey: $SUPABASE_ANON_KEY" "$SUPABASE_URL/health" || true
            exit 1
          fi

          # Test database connectivity with detailed error reporting
          echo "üóÑÔ∏è Testing database connectivity..."
          DB_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 \
            "$SUPABASE_URL/rest/v1/receipts?select=id&limit=1" \
            -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
            -H "apikey: $SUPABASE_ANON_KEY" || echo "000")

          echo "Database response code: $DB_RESPONSE"

          if [ "$DB_RESPONSE" = "200" ] || [ "$DB_RESPONSE" = "404" ]; then
            echo "‚úÖ Database connectivity test passed (HTTP $DB_RESPONSE)"
          else
            echo "‚ùå Database connectivity test failed (HTTP $DB_RESPONSE)"
            echo "üîç Attempting detailed request..."
            curl -v "$SUPABASE_URL/rest/v1/receipts?select=id&limit=1" \
              -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
              -H "apikey: $SUPABASE_ANON_KEY" || true
            exit 1
          fi

      - name: Test Edge Functions
        run: |
          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          echo "üß™ Testing Edge Functions for environment: $ENVIRONMENT"

          if [[ "$ENVIRONMENT" == "production" ]]; then
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}"
          else
            SUPABASE_URL="${{ secrets.STAGING_SUPABASE_URL }}"
            SUPABASE_ANON_KEY="${{ secrets.STAGING_SUPABASE_ANON_KEY }}"
          fi

          # Test key Edge Functions if they exist
          FUNCTIONS_TO_TEST=("stripe-webhook" "process-receipt" "manage-api-keys" "unified-search")
          FAILED_FUNCTIONS=()
          SUCCESSFUL_FUNCTIONS=()

          for func in "${FUNCTIONS_TO_TEST[@]}"; do
            echo "üîç Testing function: $func"

            FUNC_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 \
              -X POST "$SUPABASE_URL/functions/v1/$func" \
              -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
              -H "Content-Type: application/json" \
              -d '{"test": true}' 2>/dev/null || echo "000")

            echo "Function $func response: HTTP $FUNC_RESPONSE"

            # Consider various response codes as success (function is deployed and responding)
            if [ "$FUNC_RESPONSE" = "200" ] || [ "$FUNC_RESPONSE" = "400" ] || [ "$FUNC_RESPONSE" = "401" ] || [ "$FUNC_RESPONSE" = "403" ]; then
              echo "‚úÖ Function $func is responding (HTTP $FUNC_RESPONSE)"
              SUCCESSFUL_FUNCTIONS+=("$func")
            else
              echo "‚ö†Ô∏è Function $func may not be deployed or accessible (HTTP $FUNC_RESPONSE)"
              FAILED_FUNCTIONS+=("$func")
            fi
          done

          # Summary
          echo ""
          echo "üìä Edge Functions Test Summary:"
          echo "‚úÖ Responding functions: ${#SUCCESSFUL_FUNCTIONS[@]}"
          echo "‚ö†Ô∏è Non-responding functions: ${#FAILED_FUNCTIONS[@]}"

          if [ ${#SUCCESSFUL_FUNCTIONS[@]} -gt 0 ]; then
            echo "‚úÖ Successful: ${SUCCESSFUL_FUNCTIONS[*]}"
          fi

          if [ ${#FAILED_FUNCTIONS[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è Failed: ${FAILED_FUNCTIONS[*]}"
            echo "‚ÑπÔ∏è Note: Some functions may not be deployed or may require specific authentication"
          fi

          # Don't fail the workflow if some functions are not responding
          # This allows for partial deployments and optional functions
          echo "‚úÖ Edge Functions validation completed"

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate, validate-migrations, validate-edge-functions, validate-deployment]
    if: always()

    steps:
      - name: Log deployment success
        if: ${{ needs.validate-deployment.result == 'success' }}
        run: |
          echo "üöÄ Supabase deployment successful!"
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Migrations: ${{ needs.validate-migrations.result }}"
          echo "Functions: ${{ needs.validate-edge-functions.result }}"
          echo "Validation: ${{ needs.validate-deployment.result }}"

      - name: Log deployment failure
        if: ${{ needs.validate.result == 'failure' || needs.validate-migrations.result == 'failure' || needs.validate-edge-functions.result == 'failure' }}
        run: |
          echo "‚ùå Supabase deployment failed!"
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Validation: ${{ needs.validate.result }}"
          echo "Migrations: ${{ needs.validate-migrations.result }}"
          echo "Functions: ${{ needs.validate-edge-functions.result }}"
          echo "Check workflow logs for details."

      - name: Log deployment status (fallback)
        if: always()
        run: |
          echo "=== Deployment Summary ==="
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Validation: ${{ needs.validate.result }}"
          echo "Migrations: ${{ needs.validate-migrations.result }}"
          echo "Functions: ${{ needs.validate-edge-functions.result }}"
          echo "Validation: ${{ needs.validate-deployment.result }}"

          echo "‚ÑπÔ∏è Slack notifications disabled"

          if [[ "${{ needs.validate-deployment.result }}" == "success" ]]; then
            echo "üöÄ Deployment completed successfully!"
          else
            echo "‚ùå Deployment failed. Check logs above for details."
          fi
