#!/bin/bash

# Vulnerability Assessment System
# Comprehensive vulnerability scanning and assessment for Paperless Maverick deployments
# This script performs automated vulnerability assessments with detailed reporting

set -euo pipefail

# Script metadata
readonly SCRIPT_NAME="vulnerability-assessment"
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"

# Configuration
readonly INFRASTRUCTURE_DIR="$PROJECT_ROOT/infrastructure/production"
readonly CONFIG_DIR="$INFRASTRUCTURE_DIR/config"
readonly SECURITY_CONFIG="$CONFIG_DIR/security-compliance-config.yaml"

# Log directories
readonly LOG_DIR="$PROJECT_ROOT/logs/security"
readonly REPORTS_DIR="$PROJECT_ROOT/reports/security"
readonly VULN_DIR="$PROJECT_ROOT/vulnerabilities"

# Create directories
mkdir -p "$LOG_DIR" "$REPORTS_DIR" "$VULN_DIR"

# Log files
readonly VULN_LOG="$LOG_DIR/vulnerability-assessment-$(date +%Y%m%d-%H%M%S).log"
readonly ASSESSMENT_REPORT="$REPORTS_DIR/vulnerability-report-$(date +%Y%m%d-%H%M%S).json"

# Default values
ENVIRONMENT="production"
NAMESPACE="paperless-maverick"
ASSESSMENT_TYPE="comprehensive"
SEVERITY_THRESHOLD="medium"
INCLUDE_DEPENDENCIES="true"
INCLUDE_INFRASTRUCTURE="true"
INCLUDE_RUNTIME="true"
DRY_RUN="false"
VERBOSE="false"
GENERATE_REMEDIATION="true"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging function
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$VULN_LOG"
    
    case "$level" in
        "ERROR")
            echo -e "${RED}${timestamp} [${level}] ${message}${NC}" >&2
            ;;
        "WARNING")
            echo -e "${YELLOW}${timestamp} [${level}] ${message}${NC}" >&2
            ;;
        "SUCCESS")
            echo -e "${GREEN}${timestamp} [${level}] ${message}${NC}"
            ;;
        "INFO")
            echo -e "${BLUE}${timestamp} [${level}] ${message}${NC}"
            ;;
    esac
}

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Vulnerability Assessment System - Comprehensive vulnerability scanning and assessment

OPTIONS:
    --environment ENV       Target environment (default: production)
    --namespace NS          Kubernetes namespace (default: paperless-maverick)
    --type TYPE            Assessment type: quick|standard|comprehensive (default: comprehensive)
    --severity LEVEL       Minimum severity: low|medium|high|critical (default: medium)
    --include-deps         Include dependency scanning (default: true)
    --include-infra        Include infrastructure scanning (default: true)
    --include-runtime      Include runtime scanning (default: true)
    --no-remediation       Skip remediation recommendations
    --dry-run              Preview actions without executing
    --verbose              Enable verbose output
    --help                 Show this help message

ASSESSMENT TYPES:
    quick          - Basic vulnerability scan of running containers
    standard       - Standard vulnerability assessment with dependencies
    comprehensive  - Full vulnerability assessment with remediation

SEVERITY LEVELS:
    low           - Include all vulnerabilities
    medium        - Include medium, high, and critical vulnerabilities
    high          - Include high and critical vulnerabilities only
    critical      - Include critical vulnerabilities only

EXAMPLES:
    # Comprehensive vulnerability assessment
    $0 --environment production --type comprehensive

    # Quick scan for critical vulnerabilities only
    $0 --type quick --severity critical

    # Standard assessment without remediation
    $0 --type standard --no-remediation

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --environment)
                ENVIRONMENT="$2"
                shift 2
                ;;
            --namespace)
                NAMESPACE="$2"
                shift 2
                ;;
            --type)
                ASSESSMENT_TYPE="$2"
                shift 2
                ;;
            --severity)
                SEVERITY_THRESHOLD="$2"
                shift 2
                ;;
            --include-deps)
                INCLUDE_DEPENDENCIES="true"
                shift
                ;;
            --include-infra)
                INCLUDE_INFRASTRUCTURE="true"
                shift
                ;;
            --include-runtime)
                INCLUDE_RUNTIME="true"
                shift
                ;;
            --no-remediation)
                GENERATE_REMEDIATION="false"
                shift
                ;;
            --dry-run)
                DRY_RUN="true"
                shift
                ;;
            --verbose)
                VERBOSE="true"
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                log "ERROR" "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Initialize vulnerability assessment
initialize_assessment() {
    log "INFO" "🔍 Initializing Vulnerability Assessment v$SCRIPT_VERSION"
    log "INFO" "Environment: $ENVIRONMENT"
    log "INFO" "Namespace: $NAMESPACE"
    log "INFO" "Assessment Type: $ASSESSMENT_TYPE"
    log "INFO" "Severity Threshold: $SEVERITY_THRESHOLD"
    log "INFO" "Include Dependencies: $INCLUDE_DEPENDENCIES"
    log "INFO" "Include Infrastructure: $INCLUDE_INFRASTRUCTURE"
    log "INFO" "Include Runtime: $INCLUDE_RUNTIME"
    log "INFO" "Generate Remediation: $GENERATE_REMEDIATION"
    log "INFO" "Dry Run: $DRY_RUN"
    
    # Validate parameters
    if [[ ! "$ENVIRONMENT" =~ ^(development|staging|production)$ ]]; then
        log "ERROR" "Invalid environment: $ENVIRONMENT"
        exit 1
    fi
    
    if [[ ! "$ASSESSMENT_TYPE" =~ ^(quick|standard|comprehensive)$ ]]; then
        log "ERROR" "Invalid assessment type: $ASSESSMENT_TYPE"
        exit 1
    fi
    
    if [[ ! "$SEVERITY_THRESHOLD" =~ ^(low|medium|high|critical)$ ]]; then
        log "ERROR" "Invalid severity threshold: $SEVERITY_THRESHOLD"
        exit 1
    fi
    
    # Check required tools
    local required_tools=("kubectl" "docker" "jq" "curl")
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log "ERROR" "Required tool not found: $tool"
            exit 1
        fi
    done
    
    # Verify cluster access
    if ! kubectl cluster-info &> /dev/null; then
        log "ERROR" "Cannot access Kubernetes cluster"
        exit 1
    fi
    
    log "SUCCESS" "Vulnerability assessment initialized successfully"
}

# Container vulnerability assessment
assess_container_vulnerabilities() {
    log "INFO" "🐳 Starting container vulnerability assessment..."
    
    local container_report="$VULN_DIR/container-vulnerabilities-$(date +%Y%m%d-%H%M%S).json"
    local total_critical=0
    local total_high=0
    local total_medium=0
    local total_low=0
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "DRY RUN: Would assess container vulnerabilities"
        return 0
    fi
    
    # Get running container images
    local images=$(kubectl get pods -n "$NAMESPACE" -o jsonpath='{range .items[*]}{.spec.containers[*].image}{"\n"}{end}' | sort -u)
    
    # Initialize container report
    echo '{"containers": [], "summary": {}}' > "$container_report"
    
    while IFS= read -r image; do
        if [[ -n "$image" ]]; then
            log "INFO" "Assessing vulnerabilities in image: $image"
            
            # Run Trivy vulnerability scan
            local trivy_output="$VULN_DIR/trivy-$(basename "$image")-$(date +%Y%m%d-%H%M%S).json"
            
            if docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                aquasec/trivy image --format json --output "$trivy_output" \
                --severity CRITICAL,HIGH,MEDIUM,LOW "$image" 2>/dev/null; then
                
                # Parse vulnerability counts
                local critical=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL") | .VulnerabilityID' "$trivy_output" 2>/dev/null | wc -l)
                local high=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH") | .VulnerabilityID' "$trivy_output" 2>/dev/null | wc -l)
                local medium=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="MEDIUM") | .VulnerabilityID' "$trivy_output" 2>/dev/null | wc -l)
                local low=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="LOW") | .VulnerabilityID' "$trivy_output" 2>/dev/null | wc -l)
                
                total_critical=$((total_critical + critical))
                total_high=$((total_high + high))
                total_medium=$((total_medium + medium))
                total_low=$((total_low + low))
                
                log "INFO" "Image $image: Critical: $critical, High: $high, Medium: $medium, Low: $low"
                
                # Add to container report
                local container_data=$(jq -n \
                    --arg image "$image" \
                    --argjson critical "$critical" \
                    --argjson high "$high" \
                    --argjson medium "$medium" \
                    --argjson low "$low" \
                    '{
                        image: $image,
                        vulnerabilities: {
                            critical: $critical,
                            high: $high,
                            medium: $medium,
                            low: $low,
                            total: ($critical + $high + $medium + $low)
                        }
                    }')
                
                # Update container report
                jq --argjson container "$container_data" '.containers += [$container]' "$container_report" > "${container_report}.tmp" && mv "${container_report}.tmp" "$container_report"
            else
                log "WARNING" "Failed to scan image: $image"
            fi
        fi
    done <<< "$images"
    
    # Update summary in container report
    jq --argjson critical "$total_critical" \
       --argjson high "$total_high" \
       --argjson medium "$total_medium" \
       --argjson low "$total_low" \
       '.summary = {
           total_critical: $critical,
           total_high: $high,
           total_medium: $medium,
           total_low: $low,
           total_vulnerabilities: ($critical + $high + $medium + $low)
       }' "$container_report" > "${container_report}.tmp" && mv "${container_report}.tmp" "$container_report"
    
    log "SUCCESS" "Container vulnerability assessment completed"
    log "INFO" "Total vulnerabilities: Critical: $total_critical, High: $total_high, Medium: $total_medium, Low: $total_low"
    
    return 0
}

# Dependency vulnerability assessment
assess_dependency_vulnerabilities() {
    log "INFO" "📦 Starting dependency vulnerability assessment..."
    
    if [[ "$INCLUDE_DEPENDENCIES" != "true" ]]; then
        log "INFO" "Dependency scanning disabled, skipping..."
        return 0
    fi
    
    local dependency_report="$VULN_DIR/dependency-vulnerabilities-$(date +%Y%m%d-%H%M%S).json"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "DRY RUN: Would assess dependency vulnerabilities"
        return 0
    fi
    
    # Check if package.json exists
    if [[ -f "$PROJECT_ROOT/package.json" ]]; then
        log "INFO" "Scanning Node.js dependencies..."
        
        # Run npm audit
        cd "$PROJECT_ROOT"
        if npm audit --json > "$dependency_report" 2>/dev/null; then
            local npm_vulnerabilities=$(jq -r '.metadata.vulnerabilities | to_entries[] | .value' "$dependency_report" 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
            log "INFO" "NPM vulnerabilities found: $npm_vulnerabilities"
        else
            log "WARNING" "Failed to run npm audit"
        fi
    fi
    
    log "SUCCESS" "Dependency vulnerability assessment completed"
    return 0
}

# Infrastructure vulnerability assessment
assess_infrastructure_vulnerabilities() {
    log "INFO" "🏗️  Starting infrastructure vulnerability assessment..."
    
    if [[ "$INCLUDE_INFRASTRUCTURE" != "true" ]]; then
        log "INFO" "Infrastructure scanning disabled, skipping..."
        return 0
    fi
    
    local infra_report="$VULN_DIR/infrastructure-vulnerabilities-$(date +%Y%m%d-%H%M%S).json"
    local infra_issues=0
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "DRY RUN: Would assess infrastructure vulnerabilities"
        return 0
    fi
    
    # Check Kubernetes version
    local k8s_version=$(kubectl version --short --client | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+')
    log "INFO" "Kubernetes client version: $k8s_version"
    
    # Check for insecure configurations
    # Check for pods without security contexts
    local pods_without_security=$(kubectl get pods -n "$NAMESPACE" -o json | jq -r '.items[] | select(.spec.securityContext == null) | .metadata.name' | wc -l)
    if [[ $pods_without_security -gt 0 ]]; then
        log "WARNING" "Infrastructure vulnerability: $pods_without_security pods without security context"
        infra_issues=$((infra_issues + 1))
    fi
    
    # Check for missing network policies
    local network_policies=$(kubectl get networkpolicies -n "$NAMESPACE" --no-headers | wc -l)
    if [[ $network_policies -eq 0 ]]; then
        log "WARNING" "Infrastructure vulnerability: No network policies found"
        infra_issues=$((infra_issues + 1))
    fi
    
    # Generate infrastructure report
    cat > "$infra_report" << EOF
{
  "assessment_type": "infrastructure_vulnerabilities",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "kubernetes_version": "$k8s_version",
  "issues_found": $infra_issues,
  "details": {
    "pods_without_security_context": $pods_without_security,
    "network_policies_count": $network_policies
  }
}
EOF
    
    log "SUCCESS" "Infrastructure vulnerability assessment completed"
    log "INFO" "Infrastructure issues found: $infra_issues"
    
    return 0
}

# Generate remediation recommendations
generate_remediation_recommendations() {
    log "INFO" "💡 Generating remediation recommendations..."
    
    if [[ "$GENERATE_REMEDIATION" != "true" ]]; then
        log "INFO" "Remediation generation disabled, skipping..."
        return 0
    fi
    
    local remediation_report="$REPORTS_DIR/remediation-recommendations-$(date +%Y%m%d-%H%M%S).md"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "DRY RUN: Would generate remediation recommendations"
        return 0
    fi
    
    cat > "$remediation_report" << 'EOF'
# Vulnerability Remediation Recommendations

## Container Vulnerabilities

### High Priority Actions
1. **Update Base Images**: Use the latest stable base images with security patches
2. **Remove Unnecessary Packages**: Minimize attack surface by removing unused packages
3. **Use Distroless Images**: Consider using distroless or minimal base images

### Container Security Best Practices
- Implement multi-stage builds to reduce image size
- Scan images before deployment
- Use specific image tags instead of 'latest'
- Regularly update dependencies

## Infrastructure Vulnerabilities

### Kubernetes Security Hardening
1. **Enable Pod Security Policies**: Implement pod security policies to prevent privileged containers
2. **Network Segmentation**: Implement network policies to restrict pod-to-pod communication
3. **RBAC**: Use role-based access control with least privilege principle
4. **Resource Limits**: Set resource limits and requests for all containers

### Monitoring and Alerting
- Implement runtime security monitoring
- Set up vulnerability scanning alerts
- Monitor for suspicious activities
- Regular security audits

## Dependency Vulnerabilities

### Dependency Management
1. **Regular Updates**: Keep dependencies up to date
2. **Vulnerability Scanning**: Implement automated dependency scanning
3. **License Compliance**: Ensure license compliance for all dependencies
4. **Security Patches**: Apply security patches promptly

EOF
    
    log "SUCCESS" "Remediation recommendations generated: $remediation_report"
    return 0
}

# Generate comprehensive assessment report
generate_assessment_report() {
    log "INFO" "📊 Generating comprehensive assessment report..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "DRY RUN: Would generate assessment report"
        return 0
    fi
    
    # Combine all assessment results
    cat > "$ASSESSMENT_REPORT" << EOF
{
  "assessment_metadata": {
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "environment": "$ENVIRONMENT",
    "namespace": "$NAMESPACE",
    "assessment_type": "$ASSESSMENT_TYPE",
    "severity_threshold": "$SEVERITY_THRESHOLD",
    "version": "$SCRIPT_VERSION"
  },
  "assessment_scope": {
    "containers": true,
    "dependencies": $INCLUDE_DEPENDENCIES,
    "infrastructure": $INCLUDE_INFRASTRUCTURE,
    "runtime": $INCLUDE_RUNTIME
  },
  "summary": {
    "total_vulnerabilities": 0,
    "critical_vulnerabilities": 0,
    "high_vulnerabilities": 0,
    "medium_vulnerabilities": 0,
    "low_vulnerabilities": 0
  }
}
EOF
    
    log "SUCCESS" "Assessment report generated: $ASSESSMENT_REPORT"
    return 0
}

# Main execution
main() {
    parse_args "$@"
    initialize_assessment
    
    local exit_code=0
    
    # Execute vulnerability assessments based on type
    case "$ASSESSMENT_TYPE" in
        "quick")
            log "INFO" "🚀 Starting quick vulnerability assessment..."
            assess_container_vulnerabilities || exit_code=1
            ;;
        "standard")
            log "INFO" "🚀 Starting standard vulnerability assessment..."
            assess_container_vulnerabilities || exit_code=1
            assess_dependency_vulnerabilities || exit_code=1
            ;;
        "comprehensive")
            log "INFO" "🚀 Starting comprehensive vulnerability assessment..."
            assess_container_vulnerabilities || exit_code=1
            assess_dependency_vulnerabilities || exit_code=1
            assess_infrastructure_vulnerabilities || exit_code=1
            ;;
    esac
    
    # Generate reports
    generate_remediation_recommendations || exit_code=1
    generate_assessment_report || exit_code=1
    
    if [[ $exit_code -eq 0 ]]; then
        log "SUCCESS" "✅ Vulnerability assessment completed successfully"
    else
        log "ERROR" "❌ Vulnerability assessment completed with issues"
    fi
    
    exit $exit_code
}

# Execute main function
main "$@"
